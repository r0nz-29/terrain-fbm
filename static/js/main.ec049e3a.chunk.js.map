{"version":3,"sources":["World/resizer.js","World/Loop.js","World/controls.js","World/maps/river.png","World/maps/sand.jpg","World/maps/water1.jpg","World/index.js","World/scene.js","World/camera.js","World/renderer.js","World/lights.js","World/terrain.js","App.jsx","index.js"],"names":["setSize","container","camera","renderer","aspect","clientWidth","clientHeight","updateProjectionMatrix","setPixelRatio","window","devicePixelRatio","Loop","scene","this","_camera","_scene","_renderer","_needsUpdate","_controls","canvas","type","controls","OrbitControls","enableDamping","FirstPersonControls","createControls","domElement","_objectsWithBehaviour","clock","time","setAnimationLoop","update","getDelta","forEach","obj","material","uniforms","u_time","value","behaviour","render","World","THREE","position","set","createCamera","antialias","alpha","physicallyCorrectLights","shadowMap","enabled","createRenderer","appendChild","_resizer","addEventListener","resizer","_time","_loop","light","castShadow","createLights","land","heightMap","load","heightmap","wrapS","wrapT","colorMap","colormap","Water","water","u_heightmap","u_colormap","u_water","vertexShader","fragmentShader","side","geometry","createTerrain","rotation","x","Math","PI","add","_clock","start","stop","App","React","useEffect","root","document","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.ec049e3a.chunk.js","sourcesContent":["const setSize = (container, camera, renderer) => {\n  camera.aspect = container.clientWidth / container.clientHeight;\n  camera.updateProjectionMatrix();\n  renderer.setSize(container.clientWidth, container.clientHeight);\n  renderer.setPixelRatio(window.devicePixelRatio);\n};\n\nexport const resizer = (container, camera, renderer) => {\n  setSize(container, camera, renderer);\n  window.addEventListener('resize', ()=>{\n    setSize(container, camera, renderer);\n  });\n}\n","import { createControls } from './controls';\n\nclass Loop {\n  constructor(camera, scene, renderer){\n    this._camera = camera;\n    this._scene = scene;\n    this._renderer = renderer;\n    this._needsUpdate = [];\n    this._controls = createControls(this._camera, this._renderer.domElement, 'orbit');\n    // this._controls.lookSpeed = 0.2;\n    // this._controls.movementSpeed = 0.4;\n    // this._controls.noFly = true;\n    // this._controls.lookVertical = true;\n    // this._controls.constrainVertical = true;\n    // this._controls.verticalMin = 1.3;\n    // this._controls.verticalMax = 1.8;\n    // this._controls.activeLook = true;\n    // console.log(this._controls);\n    this._objectsWithBehaviour = [];\n  }\n\n  start(clock, time) {\n    this._renderer.setAnimationLoop(()=>{\n      //update controls\n      this._controls.update(clock.getDelta());\n\n      // //update uniforms\n      this._needsUpdate.forEach((obj)=>{\n        obj.material.uniforms.u_time.value += 0.01;\n      })\n\n      //animate objects\n      this._objectsWithBehaviour.forEach((obj)=>{\n        obj.behaviour();\n      });\n\n      //re-render scene\n      this._renderer.render(this._scene, this._camera);\n    });\n  }\n\n  stop() {\n    this._renderer.setAnimationLoop(null);\n  }\n\n}\n\nexport {Loop};","import {OrbitControls} from 'three/examples/jsm/controls/OrbitControls';\nimport {FirstPersonControls} from 'three/examples/jsm/controls/FirstPersonControls';\n\nexport const createControls = (camera, canvas, type) => {\n  if(type===\"orbit\") {\n    const controls = new OrbitControls(camera, canvas);\n    controls.enableDamping = true;\n    return controls;\n  };\n  if(type===\"firstPerson\"){\n    const controls = new FirstPersonControls(camera, canvas);\n    return controls;\n  }\n}","export default __webpack_public_path__ + \"static/media/river.d1debb43.png\";","export default __webpack_public_path__ + \"static/media/sand.44b471ae.jpg\";","export default __webpack_public_path__ + \"static/media/water1.babf6e90.jpg\";","import * as THREE from 'three';\nimport { createScene } from './scene';\nimport { createCamera } from './camera';\nimport { createRenderer } from './renderer';\n// import { Cube } from './Cube';\nimport { createLights } from './lights';\nimport { resizer } from './resizer';\nimport {Loop} from './Loop';\nimport {createTerrain} from './terrain';\n// import {createSphere} from './sphere';\n// import { createPlane } from './plane';\n\nclass World {\n  constructor(container) {\n    this._scene = createScene();\n    this._camera = createCamera();\n    this._renderer = createRenderer();\n    container.appendChild(this._renderer.domElement);\n    this._resizer = resizer(container, this._camera, this._renderer);\n    this._time = 0.0;\n    this._loop = new Loop(this._camera, this._scene, this._renderer);\n    const light = createLights();\n    // const sphere = createSphere(this._time);\n    // const plane = createPlane();\n    const land = createTerrain(this._time);\n    land.rotation.x = -Math.PI / 2;;\n    // this._loop._needsUpdate.push(sphere);\n    this._scene.add(land, light);\n    this._clock = new THREE.Clock();\n  }\n\n  start() {\n    this._loop.start(this._clock, this._time);\n  }\n\n  stop() {\n    this._loop.stop();\n  }\n\n  render() {\n    this._renderer.render(this._scene, this._camera);\n  }\n}\nexport { World };","import * as THREE from 'three';\n\nexport const createScene = () => {\n  const scene = new THREE.Scene();\n  return scene;\n}","import * as THREE from 'three';\n\nexport const createCamera = () => {\n  const camera = new THREE.PerspectiveCamera(\n    35,\n    1,\n    0.1,\n    100\n  );\n  camera.position.set(-5, 8, 10);\n  return camera;\n}","import * as THREE from 'three';\n\nexport const createRenderer = () => {\n  const renderer = new THREE.WebGLRenderer({antialias: true, alpha:true});\n  renderer.physicallyCorrectLights = true;\n  renderer.shadowMap.enabled = true;\n  return renderer;\n}","import * as THREE from 'three';\n\nexport const createLights = () => {\n  const light = new THREE.DirectionalLight('white');\n  light.position.set(0, 4, 10);\n  light.castShadow = true;\n  // const aLight = new THREE.AmbientLight(\"white\", 2);\n  return light;\n} ","import * as THREE from 'three';\nimport heightmap from './maps/river.png';\nimport colormap from './maps/sand.jpg';\nimport water from './maps/water1.jpg';\n\nconst VS_bak = `\n  uniform float u_time;\n  uniform sampler2D u_water;\n  uniform sampler2D u_heightmap;\n  varying float height;\n  varying vec2 vuv;\n  varying vec3 n;\n\n  void main() {\n    vuv = uv;\n    mat4 boilerplate = projectionMatrix * modelViewMatrix;\n    vec3 p = position;\n    vec3 heightData = texture2D(u_heightmap, uv).rgb;\n    vec3 waterData = texture2D(u_water, sin(uv*0.1+0.01*u_time)).rgb;\n    // height = 0.3*sin(mix(0.0, 1.0, 10.0*u_time+p.y+p.x));\n    height = 10.0*(heightData.x + heightData.y + heightData.z); \n    // if(height < 0.2) { height = 0.3*(waterData.x + waterData.y + waterData.z) ;}\n    vec3 newP = p + vec3(0.0, 0.0, 0.1*height);\n    n = normal + vec3(0.01*height);\n    gl_Position = boilerplate * vec4(newP, 1.0);\n  }\n`;\n\nconst VS = `\n  uniform float u_time;\n  uniform sampler2D u_water;\n  uniform sampler2D u_heightmap;\n  varying float height;\n  varying vec3 normalInterp;\n  varying vec3 pos;\n  varying vec2 vuv;\n\n  void main() {\n    vec3 p = position;\n    vuv = uv;\n    mat4 boilerplate = projectionMatrix * modelViewMatrix;\n    vec3 heightData = texture2D(u_heightmap, uv).rgb;\n    height = 10.0*(heightData.x + heightData.y + heightData.z); \n    vec3 newP = p + vec3(0.0, 0.0, 0.1*height);\n    vec3 newNormal = normal + vec3(0.01*height);\n\n    vec4 pos4 = modelViewMatrix * vec4(newP, 1.0);\n\n    normalInterp = newNormal;\n    pos = vec3(pos4) / pos4.w;\n\n    gl_Position = boilerplate * vec4(newP, 1.0);\n  }\n`;\n\n// const VS_for_lambert = `\n//   void main() {\n//     vec3 p = position;\n//     vec3 heightData = texture2D(u_heightmap, uv).rgb;\n//     float height = 10.0*(heightData.x + heightData.y + heightData.z); \n//     vec3 newP = p + vec3(0.0, 0.0, 0.1*height);\n//   }\n// `;\n\nconst FS_bak = `\n  uniform sampler2D u_colormap;\n  uniform float u_time;\n  uniform sampler2D u_water;\n  varying float height;\n  varying vec2 vuv;\n  varying vec3 n;\n\n  void main() {\n    vec3 teXture = texture2D(u_colormap, vuv).rgb;\n    vec3 water = texture2D(u_water, sin(vuv*0.1+0.01*u_time)).rgb;\n    vec3 color = teXture;\n    // if(height < 0.7) {color = water;}\n    gl_FragColor = vec4(clamp(n-vec3(0.0, 0.0, 1.0), 0.0, 1.0), 1.0);\n  }\n`;\n\nconst FS = ` \n varying vec3 normalInterp;\n varying vec3 pos;\n\n const vec3 lightPos \t= vec3(200,60,100);\n const vec3 ambientColor = vec3(0.2, 0.0, 0.0);\n const vec3 diffuseColor = vec3(0.3961, 0.2627, 0.1294);\n const vec3 specColor \t= vec3(1.0, 1.0, 1.0);\n \n void main() {\n   vec3 normal = mix(normalize(normalInterp), normalize(cross(dFdx(pos), dFdy(pos))), 0.3);\n   vec3 lightDir = normalize(lightPos - pos);\n \n   float lambertian = max(dot(lightDir,normal), 0.0);\n   float specular = 0.0;\n \n   if(lambertian > 0.0) {\n     vec3 viewDir = normalize(-pos);\n     vec3 halfDir = normalize(lightDir + viewDir);\n     float specAngle = max(dot(halfDir, normal), 0.0);\n     specular = pow(specAngle, 16.0);\n   }\n \n   gl_FragColor = vec4(ambientColor + lambertian * diffuseColor + specular * specColor, 1.0);\n }\n`;\n\nexport const createTerrain = (time) => {\n  const heightMap = new THREE.TextureLoader().load(heightmap);\n  heightMap.wrapS = THREE.MirroredRepeatWrapping;\n  heightMap.wrapT = THREE.MirroredRepeatWrapping;\n  const colorMap = new THREE.TextureLoader().load(colormap);\n  const Water = new THREE.TextureLoader().load(water);\n  const material = new THREE.ShaderMaterial({\n    uniforms: {\n      u_time: {\n        value: time,\n      },\n      u_heightmap: {\n        value: heightMap,\n      },\n      u_colormap: {\n        value: colorMap,\n      },\n      u_water: {\n        value: Water,\n      }\n    },\n    vertexShader: VS,\n    fragmentShader: FS,\n    side: THREE.DoubleSide,\n    // wireframe: true,\n  });\n\n  // const material = new THREE.MeshLambertMaterial({color: 0xafafaf, side: THREE.DoubleSide});\n  // material.userData.u_heightmap = { value: heightMap };\n  // material.onBeforeCompile = (shader) => {\n  //   shader.uniforms.u_heightmap = material.userData.u_heightmap;\n  //   shader.vertexShader = \"uniform sampler2D u_heightmap;\\n\" + shader.vertexShader;\n  //   shader.vertexShader = shader.vertexShader.replace(\n  //     '#include <begin_vertex>',\n  //     `\n  //       vec3 p = position;\n  //       vec3 heightData = texture2D(u_heightmap, uv).rgb;\n  //       float height = (heightData.x + heightData.y + heightData.z); \n  //       vec3 newP = p + normal * height;\n  //       vec3 transformed = newP;   \n  //     `\n  //   );\n  // }\n\n  const geometry = new THREE.PlaneGeometry(7, 7, 1000, 1000);\n  const plane = new THREE.Mesh(geometry, material);\n  // plane.castShadow = true;\n  // plane.receiveShadow = true;\n  // console.log(geometry);\n  return plane;\n}","import React from \"react\";\nimport { World } from \"./World\";\nimport \"./App.css\";\n\nconst App = () => {\n  React.useEffect(() => {\n    const root = document.getElementById(\"root\");\n    const world = new World(root);\n    world.start();\n  }, []);\n  return null;\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App.jsx';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}